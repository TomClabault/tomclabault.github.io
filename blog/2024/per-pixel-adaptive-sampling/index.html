<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Per-pixel Adaptive Sampling | Tom Clabault </title> <meta name="author" content="Tom Clabault"> <meta name="description" content="Adaptive Sampling in a Path Tracer"> <meta name="keywords" content="tom-clabault, ray-tracing, hiprt, path-tracing"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://tomclabault.github.io/blog/2024/per-pixel-adaptive-sampling/"> <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>initTheme();</script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Tom</span> Clabault </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">Blog posts </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">Projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">Repositories </a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Per-pixel Adaptive Sampling</h1> <p class="post-meta"> Created in July 25, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/path-tracing"> <i class="fa-solid fa-hashtag fa-sm"></i> path-tracing</a>   ·   <a href="/blog/category/hiprt-path-tracer"> <i class="fa-solid fa-tag fa-sm"></i> hiprt-path-tracer</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <link rel="stylesheet" href="/assets/css/ImageBox/ImageBox.css"> <script src="/assets/js/ImageBox/ImageBox.js"></script> <script src="/assets/blogs-assets/Per-Pixel-Adaptive-Sampling/ImageBox/data.js"></script> <p>Adaptive sampling is a technique that allows focusing the samples on pixels that need more of them. This is useful because not all parts of a scene are equally complex to render.</p> <p>Consider this modified cornell box for example:</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/per-pixel-adaptive-sampling/cornell_pbr_reference-480.webp 480w,/assets/img/blogs/per-pixel-adaptive-sampling/cornell_pbr_reference-800.webp 800w,/assets/img/blogs/per-pixel-adaptive-sampling/cornell_pbr_reference-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/per-pixel-adaptive-sampling/cornell_pbr_reference.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Modified caustics cornell box, reference render. </div> <p>Half of the rays of this scene don’t even intersect any geometry and directly end up in the environment where the color of the environment map is computed. The variance of the radiance of these rays is very low since a given camera ray direction basically always results in the same radiance (almost) being returned.</p> <p>However, the same cannot be said for the reflective caustic (the emissive light panel reflecting off the mirror small box) at the top right of the Cornell box. A camera ray that hits this region of the ceiling then has a fairly low chance of bouncing in direction of the small box to then bounce directly in the direction of the light. This makes the variance of these rays very high which really slows down the convergence of this part of the scene. As a result, we would like to shoot more rays at these pixels than at other parts of the scene to help with the convergence.</p> <p>Adaptive sampling allows us to do just that. The idea is to estimate the error of each pixel of the image, compare this estimated error with a user-defined threshold \(T\) and only continue to sample the pixel if the pixel’s error is still larger than the threshold.</p> <p>A very simple error metric is that of the variance of the luminance \(\sigma^2\) of the pixel. In practice, we want to estimate the variance of a pixel across the \(N\) samples \(x_k\) it has received so far.</p> <p>The variance of \(N\) samples is usually computed as:</p> \[\sigma^2 = \frac{1}{N}\sum_{k=1}^N (x_k - \mu) ^2\] <p>However, this approach would imply keeping the average of each pixel’s samples (which is the framebuffer itself so that’s fine) as well as the values of all samples seen so far (that’s not fine). Every time we want to estimate the error of a single pixel, we would then have to loop over all the previous samples to compute their difference with the average and get our variance \(\sigma^2\). Keeping track of all the samples is infeasible in terms of memory consumption (that would be 2GB of RAM/VRAM for a mere 256 samples’ floating-point luminance at 1080p) and looping over all the samples seen so far is computationally way too demanding.</p> <p>The practical solution is to evaluate the running-variance of the \(N\) pixel samples \(x_k\):</p> \[\sigma^2 = \frac{1}{N - 1} \left(\sum_{k=1}^N x_k^2 - \left( \sum_{k=1}^N x_k \right)^2\right)\] <blockquote class="block-tip"> <h5 id="note">Note</h5> <p>Due to the nature of floating point numbers, this formula can have some precision issues. <a href="https://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm" rel="external nofollow noopener" target="_blank">This</a> Wikipedia article presents good alternatives.</p> </blockquote> <p>With the variance, we can compute a 95% confidence interval \(I\):</p> \[I = 1.96 \frac{\sigma}{\sqrt{N}}\] <p>This 95% confidence interval gives us a range around our samples mean \(\mu\) and we can be 95% sure that, for the current number of samples \(N\) and and their variance \(\sigma\) that we used to compute this interval, the converged mean (true mean) of an infinite amount of samples is in that interval.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval-480.webp 480w,/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval-800.webp 800w,/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Visualization of the confidence interval <strong>I</strong> (green arrows) around <strong>µ</strong>. </div> <p>Judging by how \(I\) is computed, it is easy to see that as the number of samples \(N\) increases or the variance \(\sigma^2\) decreases (and thus \(\sigma\) decreases too), \(I\) decreases.</p> <p>That should make sense since as we increase the number of samples, our mean \(\mu\) should get closer and closer to the “true” mean value of the pixel (which is the value of the fully converged pixel when an infinite amount of samples are averaged together).</p> <p>If \(I\) gets smaller, this means for our \(\mu\) that it also gets closer to the “true” mean and that is the sign that our pixel has converged a little more.</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval2-480.webp 480w,/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval2-800.webp 800w,/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval2-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/per-pixel-adaptive-sampling/confidenceInterval2.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> As the number of samples increases (or as the computed variance decreases), <strong>I</strong> gets smaller, meaning that the true mean is closer to our current mean which in turn means that our pixel has converged a little more. </div> <p>Knowing that we can interpret \(I\) as a measure of the convergence of our pixel, the question now becomes:</p> <p><strong>When do we assume that our pixel has sufficiently converged and stop sampling?</strong></p> <p>We use that user-given threshold \(T\) we talked about earlier! Specifically, we can assume that if \(I \leq T\mu\), rhen that pixel has converged enough for that threshold \(T\). As a practical example, consider \(T=0\). We then have:</p> \[\displaylines{I \leq T\mu \\ I \leq 0}\] <p>If \(I=0\), then the interval completely collapses on \(\mu\). Said otherwise, \(\mu\) <strong>is</strong> the true mean and our pixel has completely converged. Thus, for \(T=0\), we will only stop sampling the pixel when it has fully converged.</p> <p>In practice, having \(I=0\) is infeasible. After some experimentations a \(T\) threshold of \(0.1\) seems to target a visually very reasonable amount of noise. Any \(T\) lower than that represents quite the overhead in terms of rendering times but can still provide some improvements on the perceived level of noise:</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/per-pixel-adaptive-sampling/cornellThreshold-480.webp 480w,/assets/img/blogs/per-pixel-adaptive-sampling/cornellThreshold-800.webp 800w,/assets/img/blogs/per-pixel-adaptive-sampling/cornellThreshold-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/per-pixel-adaptive-sampling/cornellThreshold.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Comparison of the noise level obtained after all pixels have converged and stopped sampling with a varying <strong>T</strong> threshold. </div> <p>Now if you look at the render with \(T=0.1\), you’ll notice that the caustic on the ceiling is awkwardly noisier than the rest of the image. There are some “holes” in the caustic (easy to see when you compare it to the \(T=0.05\) render).</p> <p>This is an issue of the per-pixel approach used here: because that caustic has so much variance, it is actually possible that we sample a pixel on the ceiling 50 times (arbitrary number) without ever finding a path to the light. The sampled pixel will then remain gray-ish (diffuse color of the ceiling) instead of being bright because of the caustic. Our evaluation of the error of this pixel will then assume that it has converged since it has gone through 50 samples without that much of a change in radiance, meaning that it has a low variance, meaning that we can stop sampling it.</p> <p>But we shouldn’t! If we had sampled it maybe 50 more times, we would have probably found a path that leads to the light, spiking the variance of the pixel which in turn would be sampled until the variance has attenuated enough so that our confidence interval \(I\) is small again and gets below our threshold.</p> <p>One solution is simply to increase the minimum number of samples that must be traced through a pixel before evaluating its error. This way, the pixels of the image all get a chance to show their true variance and can’t escape the adaptive sampling strategy!</p> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/blogs/per-pixel-adaptive-sampling/minimumSampleNumber-480.webp 480w,/assets/img/blogs/per-pixel-adaptive-sampling/minimumSampleNumber-800.webp 800w,/assets/img/blogs/per-pixel-adaptive-sampling/minimumSampleNumber-1400.webp 1400w," sizes="95vw" type="image/webp"></source> <img src="/assets/img/blogs/per-pixel-adaptive-sampling/minimumSampleNumber.jpg" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="lazy" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> <div class="caption"> Impact of the minimum amount of samples to trace before starting evaluating adaptive sampling for the same <strong>T</strong> threshold. </div> <p>This is however a poor solution since this forces all pixels of the image to be sampled at least 100 times, even the ones that would only need 50 samples. This is a waste of computational resources.</p> <p>A better way of estimating the error of the scene will be presented in a future blog post on “Hierarchical Adaptive Sampling”.</p> <p>Nonetheless, this naive way of estimating the error of a pixel can provide very appreciable speedups in rendering time.</p> <div id="ImageBoxContent"></div> <script>content=document.getElementById("ImageBoxContent"),data.imageBoxes&&new ImageBox(content,data.imageBoxes,1280,720);</script> <table data-click-to-select="true" data-height="460" data-pagination="true" data-search="true" data-toggle="table" data-url="/assets/blog-assets/Per-Pixel-Adaptive-Sampling/ImageBox/table_data.json"> <thead> <tr> <th data-checkbox="true"></th> <th data-field="id" data-halign="left" data-align="center" data-sortable="true">ID</th> <th data-field="name" data-halign="center" data-align="right" data-sortable="true">Item Name</th> <th data-field="price" data-halign="right" data-align="left" data-sortable="true">Item Price</th> </tr> </thead> </table> <p>A few notes:</p> <ul> <li>Do not compare times between categories (i.e. between McLaren P1 @ 90% and McLaren P1 @ 95). Some images were rendered with the GPU limiter feature of my renderer (to avoid burning my GPU for hours) and some times are not always comparable between categories. Two images of the same category were rendered with the exact same settings so times are comparable there.</li> <li>behhh, it’s noisier, so bad!</li> <li>talk abut denoiser</li> <li>talk about holes, missing bright spots on the P1</li> </ul> </div> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Tom Clabault. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>addBackToTop();</script> </body> </html>